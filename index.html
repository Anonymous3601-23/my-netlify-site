<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enter the Portal</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 800px at 70% 20%, rgba(240,240,255,0.9), rgba(100,140,255,0.85) 30%, #1a2a6c 75%);
      overflow: hidden;
      font-family: 'Orbitron', ui-sans-serif, system-ui;
    }

    .frame {
      position: fixed; inset: 0; pointer-events: none;
      border: 8px solid #000; border-radius: 18px;
      box-shadow: 0 0 25px rgba(255,255,255,0.15), 0 0 45px rgba(0,0,0,0.8) inset;
    }

    canvas.bg {
      position: fixed; inset: 0; width: 100vw; height: 100vh; display: block;
    }
    #portal { opacity: 0; transition: opacity 200ms ease; }
    #portal.active { opacity: 1; }

    .center {
      position: relative; z-index: 5; height: 100vh; width: 100vw;
      display: grid; place-items: center;
    }
    .card {
      --glow: rgba(255,0,60,0.8);
      background: rgba(20,20,40,0.6);
      backdrop-filter: blur(10px);
      border: 2px solid #ff1a1a;
      border-radius: 20px;
      padding: 30px 36px;
      box-shadow: 0 0 20px rgba(255,0,0,0.5), 0 0 50px rgba(255,255,255,0.15) inset;
      display: flex; align-items: center; gap: 18px;
      animation: floaty 6s ease-in-out infinite;
    }
    @keyframes floaty { 0%,100%{ transform: translateY(0) } 50%{ transform: translateY(-12px) } }

    .cta {
      text-decoration: none; color: #fff; font-weight: 700; letter-spacing: 0.5px;
      display: inline-flex; align-items: center; gap: 12px;
      padding: 16px 20px; border-radius: 14px; border: 2px solid #ff1a1a;
      background: linear-gradient(180deg, #2a2a40, #1a1a2a);
      box-shadow: 0 0 20px var(--glow), 0 0 40px rgba(255,0,0,0.5);
      position: relative; overflow: hidden;
      transition: transform 200ms ease, box-shadow 200ms ease;
    }
    .cta:before {
      content: ""; position: absolute; inset: -200%;
      background: conic-gradient(from 0deg, rgba(255,0,0,0.5), rgba(255,255,255,0.3), rgba(255,0,0,0.5));
      animation: spin 2s linear infinite;
      filter: blur(24px);
    }
    .cta span { position: relative; z-index: 2; }
    .cta:hover { transform: scale(1.05); box-shadow: 0 0 30px var(--glow), 0 0 60px rgba(255,0,0,0.7); }
    .cta:active { transform: scale(0.97); }
    @keyframes spin { to { transform: rotate(1turn); } }

    .discord-icon { width: 38px; height: 28px; filter: drop-shadow(0 0 12px rgba(255,0,0,0.8)); }

    .title { font-size: clamp(22px, 3vw, 32px); font-weight: 900; color: #fff; text-transform: uppercase; text-shadow: 0 0 10px rgba(255,0,0,0.7); }
    .subtitle { font-size: clamp(14px, 2vw, 18px); opacity: 0.85; color: #ddd; font-weight: 600; }

    .vignette { position: fixed; inset: 0; pointer-events: none; z-index: 4; }
    .vignette:before {
      content: ""; position: absolute; inset: 0; border-radius: 20px;
      box-shadow: inset 0 0 180px rgba(0,0,0,0.7), inset 0 0 260px rgba(255,0,0,0.25);
      animation: breathe 8s ease-in-out infinite;
    }
    @keyframes breathe { 0%,100%{ opacity: .9 } 50%{ opacity: .5 } }

    .cta:focus-visible { outline: 4px dashed #ff3737; outline-offset: 4px; }
    noscript { position: fixed; bottom: 12px; left: 12px; right: 12px; background: #fff; padding: 8px 12px; border: 2px solid #000; border-radius: 10px; z-index: 99; }
  </style>
</head>
<body>
  <canvas id="snow" class="bg" aria-hidden="true"></canvas>
  <canvas id="portal" class="bg" aria-hidden="true"></canvas>

  <div class="center">
    <div class="card">
      <svg class="discord-icon" viewBox="0 0 245 240" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path fill="#ff1a1a" d="M104.4 104.9c-5.7 0-10.2 5-10.2 11.1s4.6 11.1 10.2 11.1c5.7 0 10.2-5 10.2-11.1.1-6.1-4.5-11.1-10.2-11.1zm36.2 0c-5.7 0-10.2 5-10.2 11.1s4.6 11.1 10.2 11.1c5.7 0 10.2-5 10.2-11.1s-4.5-11.1-10.2-11.1z"/>
        <path fill="#ff1a1a" d="M189.5 20.3A198.9 198.9 0 0 0 156.7 10l-1.7 3.5c23.2 5.8 34 14.2 34 14.2-14.3-7.1-28.3-10.7-41.3-12.1-10-1.1-19.6-.8-28.2.3-1.7.2-3.3.4-4.9.7-4.6.7-15.8 2.1-30.9 8.3-5 2.1-8 3.7-8 3.7s10.8-8.4 34-14.2L99 10a198.9 198.9 0 0 0-32.8 10.3C43.8 42 34.3 62.6 34.3 62.6c0 .1 18.8-29.4 57-37l-8.9 19.4c.1 0 7.6-5.7 21-10.2 7.4-2.4 16.5-4.6 27.2-4 9.4.5 19.4 2.4 29.6 6.2 3.9 1.5 7.9 3.3 11.9 5.5 0 0-3.5-8-9.5-18.8 38.2 7.6 57 37 57 37S201.2 42 189.5 20.3z"/>
      </svg>

      <div>
        <div class="title">Join Our Discord</div>
        <div class="subtitle">Step into the futuristic portal</div>
        <a id="discordLink" class="cta" href="https://discord.gg/u5ydZCAn3x">
          <span>Enter Portal</span>
        </a>
      </div>
    </div>
  </div>

  <div class="vignette" aria-hidden="true"></div>
  <div class="frame" aria-hidden="true"></div>

  <noscript>
    Enable JavaScript for portal effects & sounds.
  </noscript>

  <script>
    function fitCanvas(c) { c.width = innerWidth * devicePixelRatio; c.height = innerHeight * devicePixelRatio; }

    const snow = document.getElementById('snow');
    const sctx = snow.getContext('2d');
    const flakes = [];
    const FLAKE_COUNT = 160;

    function resetFlake(f) {
      f.x = Math.random() * snow.width;
      f.y = -Math.random() * snow.height;
      f.r = (Math.random() * 2 + 1) * devicePixelRatio;
      f.vy = (Math.random() * 1 + 0.8) * devicePixelRatio;
      f.vx = (Math.random() - 0.5) * 0.5 * devicePixelRatio;
      f.spin = Math.random() * Math.PI * 2;
      f.spinV = (Math.random() - 0.5) * 0.05;
    }

    function drawFlake(f) {
      sctx.save();
      sctx.translate(f.x, f.y);
      sctx.rotate(f.spin);
      sctx.strokeStyle = '#ff1a1a';
      sctx.globalAlpha = 0.9;
      sctx.lineWidth = Math.max(1, f.r * 0.7);
      sctx.beginPath();
      for (let i=0;i<6;i++) {
        const a = i * Math.PI/3;
        sctx.moveTo(0,0);
        sctx.lineTo(Math.cos(a)*f.r*3.5, Math.sin(a)*f.r*3.5);
      }
      sctx.stroke();
      sctx.restore();
    }

    function tickSnow() {
      sctx.clearRect(0,0,snow.width,snow.height);
      for (const f of flakes) {
        f.y += f.vy; f.x += f.vx; f.spin += f.spinV;
        if (f.y - f.r*3 > snow.height) { resetFlake(f); f.y = -10 * devicePixelRatio; }
        if (f.x < -20 * devicePixelRatio) f.x = snow.width + 20 * devicePixelRatio;
        if (f.x > snow.width + 20 * devicePixelRatio) f.x = -20 * devicePixelRatio;
        drawFlake(f);
      }
      requestAnimationFrame(tickSnow);
    }

    function initSnow() {
      fitCanvas(snow);
      flakes.length = 0;
      for (let i=0;i<FLAKE_COUNT;i++) { const f = {}; resetFlake(f); flakes.push(f); }
      tickSnow();
    }

    const portal = document.getElementById('portal');
    const pctx = portal.getContext('2d');
    let portalActive = false;

    function drawPortal(t) {
      pctx.clearRect(0,0,portal.width, portal.height);
      const w = portal.width, h = portal.height;
      const cx = w/2, cy = h/2;
      const pulse = 0.6 + 0.4 * Math.sin(t*8);
      const bg = pctx.createRadialGradient(cx, cy, Math.min(w,h)*0.02, cx, cy, Math.max(w,h)*0.7);
      bg.addColorStop(0, `rgba(255,255,255,${0.9 - pulse*0.3})`);
      bg.addColorStop(1, `rgba(255,26,26,${0.35 + pulse*0.45})`);
      pctx.fillStyle = bg;
      pctx.fillRect(0,0,w,h);

      pctx.save();
      pctx.translate(cx, cy);
      pctx.globalCompositeOperation = 'lighter';
      const arms = 5;
      const turns = 8;
      const maxR = Math.hypot(w,h) * 0.6;
      for (let a = 0; a < arms; a++) {
        pctx.beginPath();
        for (let ang = 0; ang < Math.PI * 2 * turns; ang += 0.05) {
          const progress = ang / (Math.PI*2*turns);
          const r = progress * maxR;
          const swirl = ang + t * 8 + a * (Math.PI*2/arms);
          const x = Math.cos(swirl) * r;
          const y = Math.sin(swirl) * r;
          if (ang === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);
        }
        pctx.strokeStyle = `rgba(255, ${Math.floor(80 + 60*Math.sin(t*4))}, ${Math.floor(80 + 60*Math.cos(t*3))}, 0.9)`;
        pctx.lineWidth = 5 * devicePixelRatio;
        pctx.shadowBlur = 25; pctx.shadowColor = '#ff1a1a';
        pctx.stroke();
      }
      pctx.restore();

      for (let i=0;i<8;i++) {
        const r = (t*500 + i*100) % (Math.max(w,h));
        pctx.beginPath();
        pctx.arc(cx, cy, r, 0, Math.PI*2);
        pctx.strokeStyle = 'rgba(255,255,255,0.8)';
        pctx.lineWidth = 2 * devicePixelRatio;
        pctx.stroke();
      }
    }

    function runPortal(durationMs = 2200) {
      if (portalActive) return; portalActive = true;
      fitCanvas(portal); portal.classList.add('active');
      const start = performance.now();

      function loop(now) {
        const t = (now - start) / 1000;
        drawPortal(t);
        if (now - start < durationMs) requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
      return new Promise(resolve => setTimeout(resolve, durationMs));
    }

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let actx, master;
    function initAudio() {
      if (actx) return;
      actx = new AudioCtx();
      master = actx.createGain(); master.gain.value = 0.7; master.connect(actx.destination);
    }

    function beep(freq=1000, dur=0.1) {
      initAudio();
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = 'sawtooth'; o.frequency.value = freq;
      g.gain.setValueAtTime(0, actx.currentTime);
      g.gain.linearRampToValueAtTime(0.4, actx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime + dur);
      o.connect(g).connect(master);
      o.start(); o.stop(actx.currentTime + dur + 0.02);
    }

    function whoosh(dur=2.2) {
      initAudio();
      const bufferSize = actx.sampleRate * dur;
      const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<bufferSize; i++) { data[i] = (Math.random()*2 - 1) * Math.pow(1 - i/bufferSize, 0.25); }
      const src = actx.createBufferSource(); src.buffer = buffer;
      const bp = actx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 180;
      const g = actx.createGain(); g.gain.value = 0.001;
      src.connect(bp).connect(g).connect(master);
      bp.frequency.setValueAtTime(180, actx.currentTime);
      bp.frequency.exponentialRampToValueAtTime(5000, actx.currentTime + dur*0.8);
      g.g
